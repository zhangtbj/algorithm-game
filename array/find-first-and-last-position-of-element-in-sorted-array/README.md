# 查找目标值的范围

本文档总结了代码中实现的查找目标值在有序数组中起始和结束位置的算法核心思路。

---

## 问题描述

给定一个有序数组 `nums` 和一个目标值 `target`，目标是找到目标值在数组中的起始和结束位置。如果目标值不存在，返回 `[-1, -1]`。

---

## 算法核心思路

### 整体流程
1. 通过调用两个辅助函数 `searchFirstEqualElement` 和 `searchLastEqualElement`，分别查找目标值的第一个和最后一个出现的位置。
2. 如果目标值存在于数组中，这两个函数将分别返回起始和结束索引；如果目标值不存在，则返回 `[-1, -1]`。

这一题是经典的二分搜索变种题。二分搜索有 4 大基础变种题：
- 查找第一个值等于给定值的元素
- 查找最后一个值等于给定值的元素
- 查找第一个大于等于给定值的元素
- 查找最后一个小于等于给定值的元素

### 辅助函数的具体逻辑

#### `searchFirstEqualElement` - 查找第一个等于目标值的元素位置
- **输入**：有序数组 `nums` 和目标值 `target`。
- **逻辑**：
   1. 使用二分查找的方式，维护 `start` 和 `end` 两个指针。
   2. 计算中间位置 `mid`。
   3. 如果 `nums[mid] == target`，检查是否是第一个目标值：
      - 如果是数组的第一个元素，或者 `nums[mid-1] != target`，返回当前索引。
      - 否则将搜索范围缩小为左半部分，即 `end = mid - 1`。
   4. 如果 `nums[mid] < target`，移动 `start = mid + 1`。
   5. 如果 `nums[mid] > target`，移动 `end = mid - 1`。
   6. 若未找到目标值，返回 `-1`。

#### `searchLastEqualElement` - 查找最后一个等于目标值的元素位置
- **输入**：有序数组 `nums` 和目标值 `target`。
- **逻辑**：
   1. 同样使用二分查找，维护 `start` 和 `end` 两个指针。
   2. 如果 `nums[mid] == target`，检查是否是最后一个目标值：
      - 如果是数组的最后一个元素，或者 `nums[mid+1] != target`，返回当前索引。
      - 否则将搜索范围缩小为右半部分，即 `start = mid + 1`。
   3. 如果 `nums[mid] < target`，移动 `start = mid + 1`。
   4. 如果 `nums[mid] > target`，移动 `end = mid - 1`。
   5. 若未找到目标值，返回 `-1`。

---

## 时间复杂度

- **每个函数的时间复杂度**：二分查找的时间复杂度为 $O(\log n)$。
- **总体时间复杂度**：两个函数各执行一次，整体时间复杂度为 $O(\log n)$。