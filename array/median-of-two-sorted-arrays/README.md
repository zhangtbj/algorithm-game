# 寻找两个正序数组中位数的二分查找法

## 核心思想

通过对较短的数组进行二分查找，将两个数组划分为两个部分，使得左侧部分的元素总数等于或多于右侧部分的元素总数，且左侧的最大值小于等于右侧的最小值。该方法的时间复杂度为 **O(log(min(m, n)))**，其中 `m` 和 `n` 是两个数组的长度。

## 关键点

1. **选择较短的数组进行二分**：  
   二分查找总是对较短的数组执行，以减少时间复杂度并避免越界问题。

2. **划分条件**：  
   寻找一种划分方式，使得：
    - 左侧部分的总元素数为 `(m + n + 1) / 2`，保证左侧可能比右侧多一个元素（用于处理奇数长度的情况）。
    - 左侧部分的最大值小于等于右侧部分的最小值。

3. **奇偶处理**：
    - 如果总长度为奇数，中位数为左侧部分的最大值。
    - 如果总长度为偶数，中位数为左侧最大值与右侧最小值的平均值。

4. **边界情况**：
    - 一个数组为空时，直接返回另一个数组的中位数。
    - 分割点在数组边界时，要特别处理越界问题。

## 步骤

1. **初始化变量**：
    - 定义 `low = 0` 和 `high = 较短数组的长度`。
    - 确定左侧需要的总元素数 `k = (m + n + 1) / 2`。

2. **进行二分查找**：
    - 计算较短数组的分割点 `midNums1 = low + (high - low) / 2`。
    - 根据 `k` 计算较长数组的分割点 `midNums2 = k - midNums1`。
    - 检查分割是否符合条件：
        - 如果较短数组左侧最大值大于较长数组右侧最小值，说明分割点太靠右，移动 `high = midNums1 - 1`。
        - 如果较长数组左侧最大值大于较短数组右侧最小值，说明分割点太靠左，移动 `low = midNums1 + 1`。

3. **找到合适的分割点**：
    - 当条件满足时，计算左侧最大值 `midLeft` 和右侧最小值 `midRight`：
        - `midLeft` 为两数组左侧部分的最大值。
        - `midRight` 为两数组右侧部分的最小值。
    - 根据总长度的奇偶性返回结果：
        - 如果是奇数，返回 `midLeft`。
        - 如果是偶数，返回 `(midLeft + midRight) / 2`。

## 示例

假设有两个正序数组 `nums1 = [1, 3]` 和 `nums2 = [2]`：
- 总长度为 3（奇数），最终中位数为左侧最大值 `midLeft = 2`。
- 如果两个数组分别为 `[1, 2]` 和 `[3, 4]`，总长度为 4（偶数），最终中位数为 `(midLeft + midRight) / 2 = 2.5`。

---

通过二分查找的方法，可以高效地计算两个正序数组的中位数，避免了直接合并数组的 O(m + n) 时间复杂度。
